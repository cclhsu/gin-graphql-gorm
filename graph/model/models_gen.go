// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AuthResponse struct {
	Token string `json:"token"`
}

type CommonDate struct {
	CreatedAt	string	`json:"createdAt"`
	CreatedBy	string	`json:"createdBy"`
	UpdatedAt	string	`json:"updatedAt"`
	UpdatedBy	string	`json:"updatedBy"`
	StartedAt	*string `json:"startedAt,omitempty"`
	StartedBy	*string `json:"startedBy,omitempty"`
	StartDate	*string `json:"startDate,omitempty"`
	EndDate		*string `json:"endDate,omitempty"`
	CompletedAt *string `json:"completedAt,omitempty"`
	CompletedBy *string `json:"completedBy,omitempty"`
}

type CommonDateInput struct {
	CreatedAt	string	`json:"createdAt"`
	CreatedBy	string	`json:"createdBy"`
	UpdatedAt	string	`json:"updatedAt"`
	UpdatedBy	string	`json:"updatedBy"`
	StartedAt	*string `json:"startedAt,omitempty"`
	StartedBy	*string `json:"startedBy,omitempty"`
	StartDate	*string `json:"startDate,omitempty"`
	EndDate		*string `json:"endDate,omitempty"`
	CompletedAt *string `json:"completedAt,omitempty"`
	CompletedBy *string `json:"completedBy,omitempty"`
}

type Data struct {
	Message *string `json:"message,omitempty"`
}

type HealthRequestInput struct {
	Service string `json:"service"`
}

type HealthResponse struct {
	Service string		  `json:"service"`
	Status	ServingStatus `json:"status"`
	Message *string		  `json:"message,omitempty"`
}

type HelloJSONResponse struct {
	Data *Data `json:"data"`
}

type IDUUIDDto struct {
	ID	 string `json:"ID"`
	UUID string `json:"UUID"`
}

type IDUUIDDTOInput struct {
	ID	 string `json:"ID"`
	UUID string `json:"UUID"`
}

type LoginInput struct {
	ID		 string `json:"ID"`
	Email	 string `json:"email"`
	Password string `json:"password"`
}

type LogoutResponse struct {
	Success bool `json:"success"`
}

type RegisterInput struct {
	ID		 string				`json:"ID"`
	Metadata *UserMetadataInput `json:"metadata"`
	Content	 *UserContentInput	`json:"content"`
}

type Team struct {
	ID		 string		   `json:"ID"`
	UUID	 string		   `json:"UUID"`
	Metadata *TeamMetadata `json:"metadata"`
	Content	 *TeamContent  `json:"content"`
}

type TeamContent struct {
	Email		 string		  `json:"email"`
	Members		 []*IDUUIDDto `json:"members"`
	ProductOwner *IDUUIDDto	  `json:"productOwner"`
	ScrumMaster	 *IDUUIDDto	  `json:"scrumMaster"`
}

type TeamContentInput struct {
	Email		 string			   `json:"email"`
	Members		 []*IDUUIDDTOInput `json:"members"`
	ProductOwner *IDUUIDDTOInput   `json:"productOwner"`
	ScrumMaster	 *IDUUIDDTOInput   `json:"scrumMaster"`
}

type TeamInput struct {
	ID		 *string			`json:"ID,omitempty"`
	UUID	 *string			`json:"UUID,omitempty"`
	Metadata *TeamMetadataInput `json:"metadata"`
	Content	 *TeamContentInput	`json:"content"`
}

type TeamMetadata struct {
	Name  string	  `json:"name"`
	Dates *CommonDate `json:"dates"`
}

type TeamMetadataInput struct {
	Name  string		   `json:"name"`
	Dates *CommonDateInput `json:"dates"`
}

type User struct {
	ID		 string		   `json:"ID"`
	UUID	 string		   `json:"UUID"`
	Metadata *UserMetadata `json:"metadata"`
	Content	 *UserContent  `json:"content"`
}

type UserContent struct {
	Email		 string				`json:"email"`
	Phone		 string				`json:"phone"`
	FirstName	 string				`json:"firstName"`
	LastName	 string				`json:"lastName"`
	ProjectRoles []ProjectRoleTypes `json:"projectRoles"`
	ScrumRoles	 []ScrumRoleTypes	`json:"scrumRoles"`
	Password	 string				`json:"password"`
}

type UserContentInput struct {
	Email		 string				`json:"email"`
	Phone		 string				`json:"phone"`
	FirstName	 string				`json:"firstName"`
	LastName	 string				`json:"lastName"`
	ProjectRoles []ProjectRoleTypes `json:"projectRoles"`
	ScrumRoles	 []ScrumRoleTypes	`json:"scrumRoles"`
	Password	 string				`json:"password"`
}

type UserDto struct {
	ID		 string		   `json:"ID"`
	UUID	 string		   `json:"UUID"`
	Metadata *UserMetadata `json:"metadata"`
	Content	 *UserContent  `json:"content"`
}

type UserInput struct {
	ID		 *string			`json:"ID,omitempty"`
	UUID	 *string			`json:"UUID,omitempty"`
	Metadata *UserMetadataInput `json:"metadata"`
	Content	 *UserContentInput	`json:"content"`
}

type UserMetadata struct {
	Name  string	  `json:"name"`
	Dates *CommonDate `json:"dates"`
}

type UserMetadataInput struct {
	Name  string		   `json:"name"`
	Dates *CommonDateInput `json:"dates"`
}

type UserProfileResponse struct {
	User *UserDto `json:"user"`
}

type ProjectRoleTypes string

const (
	ProjectRoleTypesProjectRoleTypesUnspecified ProjectRoleTypes = "PROJECT_ROLE_TYPES_UNSPECIFIED"
	ProjectRoleTypesProjectRoleTypesPm			ProjectRoleTypes = "PROJECT_ROLE_TYPES_PM"
	ProjectRoleTypesProjectRoleTypesEm			ProjectRoleTypes = "PROJECT_ROLE_TYPES_EM"
	ProjectRoleTypesProjectRoleTypesDev			ProjectRoleTypes = "PROJECT_ROLE_TYPES_DEV"
	ProjectRoleTypesProjectRoleTypesQa			ProjectRoleTypes = "PROJECT_ROLE_TYPES_QA"
	ProjectRoleTypesProjectRoleTypesBa			ProjectRoleTypes = "PROJECT_ROLE_TYPES_BA"
	ProjectRoleTypesProjectRoleTypesUx			ProjectRoleTypes = "PROJECT_ROLE_TYPES_UX"
	ProjectRoleTypesProjectRoleTypesO			ProjectRoleTypes = "PROJECT_ROLE_TYPES_O"
	ProjectRoleTypesUnrecognized				ProjectRoleTypes = "UNRECOGNIZED"
)

var AllProjectRoleTypes = []ProjectRoleTypes{
	ProjectRoleTypesProjectRoleTypesUnspecified,
	ProjectRoleTypesProjectRoleTypesPm,
	ProjectRoleTypesProjectRoleTypesEm,
	ProjectRoleTypesProjectRoleTypesDev,
	ProjectRoleTypesProjectRoleTypesQa,
	ProjectRoleTypesProjectRoleTypesBa,
	ProjectRoleTypesProjectRoleTypesUx,
	ProjectRoleTypesProjectRoleTypesO,
	ProjectRoleTypesUnrecognized,
}

func (e ProjectRoleTypes) IsValid() bool {
	switch e {
	case ProjectRoleTypesProjectRoleTypesUnspecified, ProjectRoleTypesProjectRoleTypesPm, ProjectRoleTypesProjectRoleTypesEm, ProjectRoleTypesProjectRoleTypesDev, ProjectRoleTypesProjectRoleTypesQa, ProjectRoleTypesProjectRoleTypesBa, ProjectRoleTypesProjectRoleTypesUx, ProjectRoleTypesProjectRoleTypesO, ProjectRoleTypesUnrecognized:
		return true
	}
	return false
}

func (e ProjectRoleTypes) String() string {
	return string(e)
}

func (e *ProjectRoleTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectRoleTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PROJECT_ROLE_TYPES", str)
	}
	return nil
}

func (e ProjectRoleTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScrumRoleTypes string

const (
	ScrumRoleTypesScrumRoleTypesUnspecified ScrumRoleTypes = "SCRUM_ROLE_TYPES_UNSPECIFIED"
	ScrumRoleTypesScrumRoleTypesPo			ScrumRoleTypes = "SCRUM_ROLE_TYPES_PO"
	ScrumRoleTypesScrumRoleTypesSm			ScrumRoleTypes = "SCRUM_ROLE_TYPES_SM"
	ScrumRoleTypesScrumRoleTypesMember		ScrumRoleTypes = "SCRUM_ROLE_TYPES_MEMBER"
	ScrumRoleTypesScrumRoleTypesO			ScrumRoleTypes = "SCRUM_ROLE_TYPES_O"
	ScrumRoleTypesUnrecognized				ScrumRoleTypes = "UNRECOGNIZED"
)

var AllScrumRoleTypes = []ScrumRoleTypes{
	ScrumRoleTypesScrumRoleTypesUnspecified,
	ScrumRoleTypesScrumRoleTypesPo,
	ScrumRoleTypesScrumRoleTypesSm,
	ScrumRoleTypesScrumRoleTypesMember,
	ScrumRoleTypesScrumRoleTypesO,
	ScrumRoleTypesUnrecognized,
}

func (e ScrumRoleTypes) IsValid() bool {
	switch e {
	case ScrumRoleTypesScrumRoleTypesUnspecified, ScrumRoleTypesScrumRoleTypesPo, ScrumRoleTypesScrumRoleTypesSm, ScrumRoleTypesScrumRoleTypesMember, ScrumRoleTypesScrumRoleTypesO, ScrumRoleTypesUnrecognized:
		return true
	}
	return false
}

func (e ScrumRoleTypes) String() string {
	return string(e)
}

func (e *ScrumRoleTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScrumRoleTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SCRUM_ROLE_TYPES", str)
	}
	return nil
}

func (e ScrumRoleTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServingStatus string

const (
	ServingStatusUnknown	ServingStatus = "UNKNOWN"
	ServingStatusServing	ServingStatus = "SERVING"
	ServingStatusNotServing ServingStatus = "NOT_SERVING"
)

var AllServingStatus = []ServingStatus{
	ServingStatusUnknown,
	ServingStatusServing,
	ServingStatusNotServing,
}

func (e ServingStatus) IsValid() bool {
	switch e {
	case ServingStatusUnknown, ServingStatusServing, ServingStatusNotServing:
		return true
	}
	return false
}

func (e ServingStatus) String() string {
	return string(e)
}

func (e *ServingStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServingStatus", str)
	}
	return nil
}

func (e ServingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
